---
layout: post
title: "谈谈 Python 中的连接符（+、+=）"
keywords: Python connect 连接符
description: "对于可变类型，+ 会创建一个新的对象，+= 则是原地操作，而对于不可变类型，两者没有区别"
category: Python
tags: python
---

假设有下面一段代码：

```python
a = [1, 2, 3, 4]
b = [5, 6, 7, 8, 9]
c = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]

for item in (a, b, c):
    item += [0] * (10 - len(item))

print a
print b
print c
```

这段代码的意思是，有三个列表，需要在长度不为 10 的列表尾部填充 0，让其长度变为10。输出如下：

```
[1, 2, 3, 4, 0, 0, 0, 0, 0, 0]
[5, 6, 7, 8, 9, 0, 0, 0, 0, 0]
[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
```

这里没什么问题，一切正常。但是，现在变了需求，需要在长度不为 10 的列表的前面填充 0。那么，我们尝试做如下的改动：

```python
a = [1, 2, 3, 4]
b = [5, 6, 7, 8, 9]
c = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]

for item in (a, b, c):
    item = [0] * (10 - len(item)) + item

print a
print b
print c
```

直接来看一下输出：

```
[1, 2, 3, 4]
[5, 6, 7, 8, 9]
[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
```

结果却不是我们想象的那样。如果你没有发现问题的所在，就继续往下看吧。当然，如果你已经看出了其中的端倪，那就不需要在这里浪费时间了。

按照我们固有的思维，上面的方法是可行，例如下面的实例：

```
>>> l = [1, 2, 3, 4, 5]
>>> l = [0]*5 + l
>>> l
[0, 0, 0, 0, 0, 1, 2, 3, 4, 5]
```

这样的操作让列表如愿以偿的得到我们所期望的改变。但是，如果我们在其中多加几个步骤呢：

```
>>> l = [1, 2, 3, 4, 5]
>>> id(l)
139935500860952
>>> l = [0]*5 + l
>>> l
[0, 0, 0, 0, 0, 1, 2, 3, 4, 5]
>>> id(l)
139935500783272
```

到此，是不是已经看出问题所在了呢。通过 id() 方法的输出可以看到，后边的 “l” 已经不是前边的 “l” 了。再看看下边的例子：

```
>>> l = [1, 2, 3, 4, 5]
>>> id(l)
139935500861024
>>> l += [0]*5
>>> l
[1, 2, 3, 4, 5, 0, 0, 0, 0, 0]
>>> id(l)
139935500861024
```

当用 `+=` 时， “l” 前后是一个。此时，我们应该明白一个事实，文章开头的例子并非莫名其妙，而是有原因的。别着急，我们再来看看例子：

```
>>> t = (1, 2, 3, 4, 5)
>>> id(t)
139935501840656
>>> t += (0,)*5
>>> t
(1, 2, 3, 4, 5, 0, 0, 0, 0, 0)
>>> id(t)
139935502151336
```

可以看到，当我们把列表换成元组时，结果又发生了变化。那么我们对元组使用 `+` 操作呢：

```
>>> t = (1, 2, 3, 4, 5)
>>> id(t)
139935501081200
>>> t = (0,)*5 + t
>>> t
(0, 0, 0, 0, 0, 1, 2, 3, 4, 5)
>>> id(t)
139935502151336
```

这与列表结果是一样的，没有什么不同。那么，再来看看字符串呢：

```
>>> s = "hello"
>>> id(s)
139935500909712
>>> s += "world"
>>> s
'helloworld'
>>> id(s)
139935500909664
```

结果如同元组，“s” 在使用 `+=` 拼接一个字符串后，被重新赋了值，已然不是之前的变量。反映在内存中就是，“s” 被另外开辟了一个存储空间来存放值。

这里，我们要谈的 Python 连接符就是 `+` 与 `+=`。要注意在 Python 中这两个符号有两层含义，一个是运用在数学中的加法运算，一个是用在序列类型上的拼接功能。不过，作为加法运算符时，也遵循本文讨论的使用规则。因为讨论这两个符号，本质上是讨论 Python 的 `immutable` 和 `mutable`，即可变类型与不可变类型。对可变类型来说，我们可以在原地对变量进行修改，也就是说它的存储空间是可读可写的，例如 list；而对于不可变类型来说，它的存储空间则是只读的，无法对其进行修改，如果需要对不可变类型进行某些操作来得到新的结果，则需要重新开辟一份存储空间来存放这个新产生的结果。

由以上列举的例子，我们可以得到如下的结论：

- 对于可变类型：
    - `+`： 代表连接操作，其结果会创建一个新的对象。
    - `+=`： 代表追加操作，即 in-place 操作，在原地把另一个对象的内容追加到对象中。

- 对于不可变类型： `+` 与 `+=` 都代表连接或求和操作，两者没有什么区别，其操作的结果都会产生一个新的对象。

除了 `+=` 外，还有 `*=`、`-=` 等也是同样的原理，这些被称之为 **增量赋值符**。它们均会调用各自的 魔法方法，如 `+=` 在实际计算时会调用 `__iadd__` 方法来得到结果。但如果 `__iadd__` 方法没有被实现，解释器就会退一步调用 `__add__` 方法。总体来说，可变序列一般都实现了 `__iadd__` 这一类增量赋值操作的方法，所以可以进行 in-place 操作，而不可变序列则没有实现这一类方法，所以其调用的是普通的运算操作方法。

下面我们来分析一下文章开头的例子，由于 for 迭代相当于赋值，为了简单起见，我们只分析 a，如下所示：

```
>>> a = [1, 2, 3, 4]
>>> t = a
>>> id(a)
139712695835400
>>> id(t)
139712695835400
>>> t += [0]*6
>>> t
[1, 2, 3, 4, 0, 0, 0, 0, 0, 0]
>>> id(t)
139712695835400
>>> id(a)
139712695835400
>>> a
[1, 2, 3, 4, 0, 0, 0, 0, 0, 0]
>>>
>>>
>>> a = [1, 2, 3, 4]
>>> t = a
>>> id(a)
139712695835464
>>> id(t)
139712695835464
>>> t = [0]*6 + t
>>> t
[0, 0, 0, 0, 0, 0, 1, 2, 3, 4]
>>> a
[1, 2, 3, 4]
>>> id(a)
139712695835464
>>> id(t)
139712695835400
```

这里， t 是对 a 的一个引用，就相当于文章开头例子的 item。用 `+=` 对 t 进行操作实际上是对 a 进行操作，而 `+=` 是原地操作，所以改变 t 时，a 也随之变化；如果用 `+` 对 t 进行操作，在将结果赋值给 t，那么此时的 t 就不再指向 a 了，而是指向 `[0]*6 + t`，所以 a 没有被改变。

这里讨论的只是一个简单的问题，而我却用了这么长的篇幅来谈论这个问题，所以我想说的是，对于这些小问题，如果你没有完全理解，那么在程序设计过程中可能会给你带来麻烦。
